<!DOCTYPE html>
<html>
<head>
    <title>Blocker Arrival Kill</title>
    <!--  (c) 2014 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Sat Jan 17 2015 20:39:25 GMT-0700 (MST) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Sat Jan 17 2015 20:39:25 GMT-0700 (MST)";
        var CHECKSUM = [%= checksum %];
    </script>
    
    <script type="text/javascript" src="https://rally1.rallydev.com/apps/2.0rc3/sdk-debug.js?apiKey=_PUT_APIKEY_HERE_"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Ext.Component',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
     title: "Build Information",
    
    renderTpl: "<div id='{id}-infolinkWrap' class='tsinfolink'>i</div>",

    initComponent: function() {
        this.callParent(arguments);
       
    },
    
    onRender: function() {
        this.callParent(arguments);
        this.mon(this.el,'click',this.onClick,this);
    },
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
        
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
    
        return chk;
    },
    _checkChecksum: function(container) {
        var me = this;
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    if ( CHECKSUM !== me._generateChecksum(text) ) {
                        console.log("Checksums don't match!");
                        if ( me.dialog ) {
                            me.dialog.add({xtype:'container',html:'Checksums do not match'});
                        }
                    }
                }
            }
        });
    },
    onClick: function(e) {
        var me = this;
        this._checkChecksum(this);
        
        var dialog_items = [];
        
        if ( this.informationHtml ) {
            dialog_items.push({
                xtype:'container',
                html: this.informationHtml
            });
        }
                
        dialog_items.push({
            xtype:'container',
            html:"This app was created by the Rally Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            dialog_items.push({
                xtype:'container',
                html:'Build date/time: ' + APP_BUILD_DATE
            });
        }
        
        if (this.dialog){this.dialog.destroy();}
        this.dialog = Ext.create('Rally.ui.dialog.Dialog',{
            defaults: { padding: 5, margin: 5 },
            closable: true,
            draggable: true,
            title: me.title,
            items: dialog_items
        });
        this.dialog.show();
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

    Ext.define("Rally.technicalservices.BlockedArtifact.Store", {
        extend : 'Ext.util.Observable',
        config: {
            startDate: null,
            endDate: new Date(),
            project: null,
            types: ['HierarchicalRequirement','Defect','Task'],
            hydrate: ['ScheduleState','State','_TypeHierarchy'],
            fetch: ['Blocked','BlockedReason','Blocker','ScheduleState','State','_TypeHierarchy'],
            compress: true, 
            find: {$or: [
               {"BlockedReason": {$exists: true}},
               {"_PreviousValues.BlockedReason": {$exists: true}}
            ]}
        },
        constructor: function(config){
            this.addEvents('artifactsloaded');       
            this.initConfig(config);
            this.callParent(arguments);
            this.loadArtifacts();
        },
        loadArtifacts: function(){
            var me = this; 
            this.find['_ValidFrom'] = {$gte: this.startDate};  
            
            Ext.create('Rally.data.lookback.SnapshotStore', {
                autoLoad: true,
                listeners: {
                    load: function(store, data, success) {
                        //process data
                        var processed_data = me._processData(data);
                        me.fireEvent('artifactsloaded', processed_data,success);
                    }
                },
                fetch: this.fetch,
                hydrate: this.hydrate,
                find: this.find,
                filters: [
                    {
                        property: '_TypeHierarchy',
                        operator: 'in',
                        value: this.types
                    },{
                        property: '_ProjectHierarchy',
                        operator: 'in',
                        value: [this.project]
                    }
                ],
                compress: this.compress 
            });
        },
        
        _processData: function(data){
            var stats = {};  
            Ext.each(data, function(snap){
                var obj_id = snap.get('ObjectID');
                if (stats[obj_id] == undefined){
                    stats[obj_id] = Ext.create('Rally.technicalservices.BlockedArtifact',snap);
                } else {
                    stats[obj_id].update(snap);
                }
            },this);
            return stats;
        }        
    });

    Ext.define("Rally.technicalservices.BlockedArtifact", {

        objectID: 0,
        artifactType: null,
        blockedDate: null,
        unblockedDate: null,
        blockedReason: null,
        blockedDateState: null,
        unblockedDateState: null, 
        blockedReason: null,
        blocker: 0,
        
        constructor: function(snapshot){
            this.objectID = snapshot.get('ObjectID');
            this.artifactType = snapshot.get('_TypeHierarchy').splice(-1)[0];
            this.update(snapshot);
        },
        update: function(snapshot){
            
            var blocked = snapshot.get('Blocked');
            var snap_date = snapshot.get('_ValidFrom');
            var state = snapshot.get('ScheduleState') || snapshot.get('State');
            
            if (blocked && ((this.blockedDate == null)||(this.blockedDate < snap_date))){
                this.blockedDate = snap_date;  
                this.blockedReason = snapshot.get('BlockedReason');
                this.blocker = snapshot.get('Blocker');
                this.blockedDateState = state;
                
            } else if (blocked == false && ((this.unblockedDate == null)||(this.unblockedDate > snap_date))) {
                    this.unblockedDate = snap_date;  
                    this.unblockedDateState = state;
            }            
        },
        getDaysToResolution: function(){
            console.log('daysToResolution',this.blockedReason, this.blockedDate, this.unblockedDate);
            if (this.blockedReason && this.blockedDate && this.unblockedDate){
                var blocked_date = Rally.util.DateTime.fromIsoString(this.blockedDate);
                var unblocked_date = Rally.util.DateTime.fromIsoString(this.unblockedDate);
                return Rally.util.DateTime.getDifference(unblocked_date, blocked_date, "day");
            }
            return null; 
        }
    });
Ext.define('Rally.technicalservices.BlockedToolbox',{
    singleton: true,
    getCountsByReason: function(artifacts){
        var counts = {};
        Ext.Object.each(artifacts, function(key, artifact){
            if (artifact.blockedReason){
                if (counts[artifact.blockedReason] == undefined){
                    counts[artifact.blockedReason] = 0; 
                } 
                counts[artifact.blockedReason]++; 
            }
        },this);
        return counts;  
    },
    bucketDataByDate: function(artifacts, artifactProperty, dateInterval, dateFormat, bucketedDateStrings){
        var buckets = {};
        console.log(bucketedDateStrings);
        Ext.each(bucketedDateStrings, function(str){
            buckets[str] = 0;
        });
        console.log(buckets);
        
        Ext.Object.each(artifacts, function(key, artifact){
            if (artifact[artifactProperty]){
                var date = Rally.util.DateTime.fromIsoString(artifact[artifactProperty]);
                var bucket = Rally.util.DateTime.format(date,dateFormat);
                if (Ext.Array.contains(bucketedDateStrings,bucket)){
                    buckets[bucket]++;
                }
            }
        });
        
        return buckets;  
    },
    getDateBuckets: function(startDate, endDate, granularity){
        console.log('_getDateBuckets',startDate,endDate,granularity);
        var start_year = startDate.getFullYear();
        var start_month = startDate.getMonth();
        var start_day = startDate.getDate();  
        if (granularity == "month"){
            start_day = 1; 
        }
        
        var end_year = endDate.getFullYear();
        var end_month = endDate.getMonth();
        var end_day = endDate.getDate() + 1; 
        if (granularity == "month"){
            //months are zero-based and 0 day returns the last day of the previous month
            end_day = new Date(end_year, end_month+1,0).getDate();
        }
        console.log(end_year,end_month,end_day);
        var bucketStartDate = new Date(start_year,start_month,start_day,0,0,0,0);
        var bucketEndDate = new Date(end_year,end_month,end_day,0,0,0,0);
        var date = bucketStartDate;
        
        var buckets = []; 
        console.log(bucketEndDate, bucketStartDate);
        while (date<bucketEndDate && bucketStartDate < bucketEndDate){
            buckets.push(date);
            date = Rally.util.DateTime.add(date,granularity,1);
        }
        return buckets;  
    },
    formatCategories: function(buckets, dateFormat){
        var categories = [];
        Ext.each(buckets, function(bucket){
            categories.push(Rally.util.DateTime.format(bucket,dateFormat));
        });
        return categories; 
    },
    getDateBucketsForArtifacts: function(artifacts, artifactProperties, dateInterval, dateFormat){
        var earliest_date = new Date();
        var latest_date = Rally.util.DateTime.add(earliest_date,"year",-20);
        
        Ext.Object.each(artifacts,function(key,artifact){
            Ext.each(artifactProperties, function(prop){
                if (artifact[prop]){
                    var date = Rally.util.DateTime.fromIsoString(artifact[prop]);
                    if (date < earliest_date){
                        earliest_date = date; 
                    }
                    if (date > latest_date){
                        latest_date = date;
                    }                
                }
            })
        });
        
        var buckets = [];
        var date = earliest_date; 
        while (date < latest_date && earliest_date < latest_date){
            var bucket = Rally.util.DateTime.format(date,dateFormat);
            console.log(date, bucket);
            if (!Ext.Array.contains(buckets, bucket)){
                buckets.push(bucket);
            }
            date = Rally.util.DateTime.add(date,dateInterval,1);
        }
        return buckets;
    },
    getStatistics: function(artifacts){
        //Mean, Min, Max, Totals
        var reasons = this.getUniquePropertyValues(artifacts,"blockedReason");
        var daysToResolution = {};  
        Ext.each(reasons, function(reason){
            daysToResolution[reason] = [];
        });
        
        Ext.Object.each(artifacts, function(key,artifact){
            if (artifact.blockedReason && artifact.unblockedDate){
                daysToResolution[artifact.blockedReason].push(artifact.getDaysToResolution());
            }
        },this);
        
        var data = [];
        var total = 0;
        Ext.Object.each(daysToResolution, function(key,val){
            total += val.length;
            data.push({reason: key, mean: Ext.Array.mean(val), min: Ext.Array.min(val), max: Ext.Array.max(val), total: val.length});
        });
        
        var all = _.flatten(_.values(daysToResolution));
        data.push({reason: 'All', mean: Ext.Array.mean(all), min: Ext.Array.min(all), max: Ext.Array.max(all), total: total});
        return data;
    },
    getUniquePropertyValues: function(artifacts, property, transformFn){
        
        var unique_values = [];  
        console.log(transformFn);
        if (transformFn == undefined){
            transformFn = function(val){return val;}
        }
        console.log('fn',transformFn);
        Ext.Object.each(artifacts, function(key,artifact){
            console.log(artifact, artifact[property]);
            if (artifact[property]){
                var val = transformFn(artifact[property]);
                console.log('val',val,Ext.Array.contains(unique_values, val));
                if (!Ext.Array.contains(unique_values, val)){
                    unique_values.push(val);
                }
            }
        });
        return unique_values.sort(); 
    }
});
    Ext.define('Rally.technicalservices.calculator.UniqueArtifactCalculator', {
        extend: 'Rally.data.lookback.calculator.BaseCalculator',
        logger: new Rally.technicalservices.Logger(),

        config: {
            startDate: null,
            endDate: new Date(),
            
            /**
             * Date format for the categories, if they are dates.  Valid formats are found in the Ext.Date object 
             */
            granularity: "month",
            categoryDateFormat: null, 
        },

        /**
         * Calculate extra chart fields that are derived based on the data retrieved by the store. This is passed
         * to the Lumenize {@link Rally.data.lookback.Lumenize.TimeSeriesCalculator TimeSeriesCalculator} as part of the
         * configuration. For example, if you want to calculate the number of completed stories, you would simply return
         * if the story is in a completed schedule state or not:
         *   return [{
         *       "as": "CompletedStoryCount",
         *       "f": function(snapshot) {
         *           var ss = snapshot.ScheduleState;
         *           if (ss === "Accepted" || ss === "Released") {
         *               return 1;
         *           }
         *           else {
         *               return 0;
         *           }
         *       }
         *   }];
         *
         * You can use these derived fields as part of the calculator metrics calculation.
         *
         * Object properties:
         *
         *   - The `as` property is the name the field is saved as for future reference
         *   - The `f` property can be a built in Lumenize function string or a custom function that takes `snapshot` as
         *   an argument
         *
         * @return {Array} a list of derived fields objects
         */
        getDerivedFieldsOnInput: function () {
            return [];
        },

        /**
         * Calculate the metrics that are displayed on the chart from the data retrieved by the store. This is passed
         * to the Lumenize {@link Rally.data.lookback.Lumenize.TimeSeriesCalculator TimeSeriesCalculator} as part of the
         * configuration. Metrics calculations can use fields that are derived using the #getDerivedFieldsOnInput
         * function. For example, if I derived a CompletedStoryCount field, I can display that field as a bar chart by
         * specifying:
         *   return [{
         *      "field": "CompletedStoryCount",
         *      "as": "Completed Stories",
         *      "f": "sum",
         *      "display": "column"
         *   }];
         *
         * The field is displayed in the chart as "Completed Stories" with each bar being a sum of that days completed
         * stories.
         *
         * Object properties:
         *
         *   - The `field` property is the field name to use to calculate the metric. This can be a field from the data
         *   or a derived field.
         *   - The `as` property is the name displayed to the user in the chart
         *   - The `f` property can be a built in Lumenize function string or a custom function that takes `snapshot` as
         *   an argument
         *   - The `display` property is used by the chart to determine how to display the data on a chart. Can be any
         *   Highcharts specific type, e.g., "line" or "column"
         *
         * @return {Array} a list of metric objects
         */
        getMetrics: function () {
            return [];
        },

        /**
         * Calculate summary metrics based on the data retrieved from the store. This is passed to the Lumenize
         * {@link Rally.data.lookback.Lumenize.TimeSeriesCalculator TimeSeriesCalculator} as part of the configuration.
         * Each summary metric also has access to any previously defined metrics or derived fields. This function is
         * useful to generate data that you do not necessarily want to render on the chart, but would like to use to get
         * more derived fields after the main chart metrics are defined. For example, if you wanted the max numbers for
         * different fields, you would specify:
         *      return [
         *          { "field": "TaskUnitScope", "f": "max" },
         *          { "field": "TaskUnitBurnDown", "f": "max" },
         *      ];
         *
         * The fields would then be available to the objects in #getDerivedFieldsAfterSummary. Note that the fields in
         * this case will need to be referenced by `TaskUnitScope_max` due to the use of the built-in `max` function. If
         * you wish to specify your own function, you must use the `as` property in order to reference the field in the
         * future. For example,
         *      return [{
         *          "as": "TaskUnitBurnDown_max_index",
         *          "f": function(seriesData, metrics) {
         *              var i, length = seriesData.length;
         *              for(i = 0; i < length; i++) {
         *                  var data = seriesData[i];
         *                  if(data.TaskUnitBurnDown == metrics.TaskUnitBurnDown_max) {
         *                      return i;
         *                  }
         *              }
         *          }
         *      }];
         *
         * Object properties:
         *
         *   - The `field` property is the name of the field to use to calculate the new summary metric. This field
         *   can be from the data or from a previously derived field.
         *   - The `as` property is only used when you supply a custom function to calculate the summary metric. It is
         *   the name for future reference of the field.
         *   - The `f` property can be a built in Lumenize function string or a custom function that takes `seriesData`
         *   and `metrics` as arguments. This is used in conjunction with the `as` property.
         *
         * @return {Array}
         */
        getSummaryMetricsConfig: function () {
            return [];
        },

        /**
         * Calculate extra chart fields to display on the chart using the fields defined in by the summary metrics
         * configuration. This is passed to the {@link Rally.data.lookback.Lumenize.TimeSeriesCalculator} as
         * part of the configuration. This function is useful when you want to derive more fields to display on your
         * chart. For example, if you wanted to calculate an ideal line for a burn chart using the `TaskUnitScope_max`
         * field, you would specify:
         *      return [{
         *          "as": "Ideal",
         *          "f": function(snapshot, index, metrics, seriesData) {
         *              var max = metrics.TaskUnitScope_max,
         *                  increments = seriesData.length - 1,
         *                  incrementAmount = max / increments;
         *
         *              return Math.floor(100 * (max - index * incrementAmount)) / 100;
         *          },
         *          "display": "line"
         *      }];
         *
         * This field would be displayed in the chart as an ideal line for the given data.
         *
         * Object properties:
         *
         *   - The `as` property is the name displayed to the user in the chart
         *   - The `f` property is a custom function that takes a snapshot, index, chart metrics, and the series data as
         *   arguments
         *   - The `display` property is used by the chart to determine how to display the data on a chart. Can be any
         *   Highcharts specific type, e.g., "line" or "column"
         *
         * @return {Array}
         */
        getDerivedFieldsAfterSummary: function () {
            return [];
        },
        runCalculation: function (snapshots) {
            this.logger.log("runCalculations snapshots",snapshots.length, snapshots);
            
            var snaps_by_oid = this._aggregateSnapshots(snapshots);
            var buckets = this._getDateBuckets(this.startDate, this.endDate, this.granularity); 
            
            var series = null;

            var categories = this._formatCategories(buckets, this.dateFormat);  
            return {categories: categories, series: series};
        },
        _getDateBuckets: function(startDate, endDate, granularity){

            var bucketStartDate = Rally.technicalservices.Toolbox.getBeginningOfMonthAsDate(startDate);
            var bucketEndDate = Rally.technicalservices.Toolbox.getEndOfMonthAsDate(endDate);
           
            this.logger.log('_getDateBuckets',startDate,bucketStartDate,endDate,bucketEndDate,granularity);
            
            var date = bucketStartDate;
            
            var buckets = []; 
            while (date<bucketEndDate && bucketStartDate < bucketEndDate){
                buckets.push(date);
                date = Rally.util.DateTime.add(date,granularity,1);
            }
            return buckets;  
        },
        _formatCategories: function(buckets, dateFormat){
            var categories = [];
            Ext.each(buckets, function(bucket){
                categories.push(Rally.util.DateTime.format(bucket,dateFormat));
            });
            return categories; 
        },
        
        /**
         * aggregateSnapsots:  returns a hash of objects (key = ObjID) with all snapshots for the object
         */
        _aggregateSnapshots: function(snapshots){
            //Return a hash of objects (key=ObjectID) with all snapshots for the object
            var snaps_by_oid = {};
            Ext.each(snapshots, function(snap){
                var oid = snap.ObjectID;
                if (snaps_by_oid[oid] == undefined){
                    snaps_by_oid[oid] = [];
                }
                snaps_by_oid[oid].push(snap);
                
            });
            return snaps_by_oid;
        }
    });
    Ext.define('Rally.technicalservices.DataExportDialog', {
        extend: 'Rally.ui.dialog.Dialog',
        logger: new Rally.technicalservices.Logger(),
        width: 700,
        autoShow: true,
        title: 'Data Dialog',

        constructor: function(config){
            Ext.apply(this,config);
            
            this.title = this.title;
            this.items = this._initializeItems();
            this.logger.log('Data dialog constructor', this.title, this.items);
            
            this.callParent(arguments);
       },
       _initializeItems: function(){
           var items = [];
           this.logger.log('_initializeItems', this.data);
           items.push(this._buildGrid());
           items.push({xtype:'container',itemId: 'button-container', items: [{
                    xtype     : 'rallybutton',
                    text      : 'Export',
                    scope: this,
                    handler      : this._export
                },{
                    xtype     : 'rallybutton',
                    text      : 'Close',
                    scope: this,
                    handler      : this._close
                }]});
           return items;
      },
      _buildGrid: function(){
          this.logger.log('_buildGrid');
          
          var store = Ext.create('Rally.data.custom.Store', {
              data: this.data,
              pageSize: 10
          });
          
          return {
              xtype:'rallygrid',
              store: store,
              columnCfgs: this._getColumnCfgs(this.data)
          };
      },
      _getColumnCfgs: function(data){
          var headers = Ext.Object.getKeys(data[0]);
          var column_cfgs = [];
          Ext.each(headers, function(header){
              column_cfgs.push({flex: 1, text: header, dataIndex: header});
          });
          return column_cfgs;  
      },
      _export: function(){
          var file_name = "export.csv";
          var data_hash = {};
          Ext.each(Ext.Object.getKeys(this.data[0]), function(key){
              data_hash[key] = key;
          });
          this.logger.log('_export',data_hash, this.data);
          
          var export_text = Rally.technicalservices.FileUtilities.convertDataArrayToCSVText(this.data, data_hash);
          Rally.technicalservices.FileUtilities.saveTextAsFile(export_text,file_name);
      },
      _close: function(){
          this.destroy();
      }
    });
Ext.define('Rally.technicalservices.FileUtilities', {
    singleton: true,
    logger: new Rally.technicalservices.Logger(),
    
    saveTextAsFile: function(textToWrite, fileName)
    {
        var textFileAsBlob = new Blob([textToWrite], {type:'text/plain'});
        var fileNameToSaveAs = fileName;

        var downloadLink = document.createElement("a");
        downloadLink.download = fileNameToSaveAs;
        downloadLink.innerHTML = "Download File";
        if (window.webkitURL != null)
        {
            // Chrome allows the link to be clicked
            // without actually adding it to the DOM.
            downloadLink.href = window.webkitURL.createObjectURL(textFileAsBlob);
        }
        else
        {
            // Firefox requires the link to be added to the DOM
            // before it can be clicked.
            downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
            downloadLink.onclick = destroyClickedElement;
            downloadLink.style.display = "none";
            document.body.appendChild(downloadLink);
        }
        downloadLink.click();
    },
    destroyClickedElement: function(event)
    {
        document.body.removeChild(event.target);
    },
    convertDataArrayToCSVText: function(data_array, requestedFieldHash){
       
        var text = '';
        Ext.each(Object.keys(requestedFieldHash), function(key){
            text += requestedFieldHash[key] + ',';
        });
        text = text.replace(/,$/,'\n');
        
        Ext.each(data_array, function(d){
            Ext.each(Object.keys(requestedFieldHash), function(key){
                if (d[key]){
                    if (typeof d[key] === 'object'){
                        if (d[key].FormattedID) {
                            text += Ext.String.format("\"{0}\",",d[key].FormattedID ); 
                        } else {
                            text += Ext.String.format("\"{0}\",",d[key].Name );                    
                        }
                    } else {
                        text += Ext.String.format("\"{0}\",",d[key] );                    
                    }
                } else {
                    text += ',';
                }
            },this);
            text = text.replace(/,$/,'\n');
        },this);
        return text;
    }
});
Ext.override(Rally.ui.chart.Chart,{
    _loadStore: function (storeConfig, storeRank) {

        var self = this;

        Ext.merge(storeConfig, {
            exceptionHandler: function (proxy, response, operation) {
                console.log(proxy,response,operation);
                if (response.status !== 200) {
                    self.queryValid = false;
                }
                if (response.status === 409) {
                    self.workspaceHalted = true;
                } else if (response.status === 503) {
                    self.serviceUnavailable = true;
                }
            }
        });

        storeConfig.limit = storeConfig.limit || Infinity;

        var store = Ext.create(this.storeType, storeConfig);
        store.rank = storeRank;

        store.on('load', this._storeLoadHandler, this);
        store.load({params: { removeUnauthorizedSnapshots: true } });
    }
});

    Ext.define('Rally.technicalservices.calculator.StateTouchCalculator', {
        extend: 'Rally.data.lookback.calculator.BaseCalculator',

        config: {
            startDate: null,
            endDate: null
        },

        /**
         * Calculate extra chart fields that are derived based on the data retrieved by the store. This is passed
         * to the Lumenize {@link Rally.data.lookback.Lumenize.TimeSeriesCalculator TimeSeriesCalculator} as part of the
         * configuration. For example, if you want to calculate the number of completed stories, you would simply return
         * if the story is in a completed schedule state or not:
         *   return [{
         *       "as": "CompletedStoryCount",
         *       "f": function(snapshot) {
         *           var ss = snapshot.ScheduleState;
         *           if (ss === "Accepted" || ss === "Released") {
         *               return 1;
         *           }
         *           else {
         *               return 0;
         *           }
         *       }
         *   }];
         *
         * You can use these derived fields as part of the calculator metrics calculation.
         *
         * Object properties:
         *
         *   - The `as` property is the name the field is saved as for future reference
         *   - The `f` property can be a built in Lumenize function string or a custom function that takes `snapshot` as
         *   an argument
         *
         * @return {Array} a list of derived fields objects
         */
        getDerivedFieldsOnInput: function () {
            return [];
        },

        /**
         * Calculate the metrics that are displayed on the chart from the data retrieved by the store. This is passed
         * to the Lumenize {@link Rally.data.lookback.Lumenize.TimeSeriesCalculator TimeSeriesCalculator} as part of the
         * configuration. Metrics calculations can use fields that are derived using the #getDerivedFieldsOnInput
         * function. For example, if I derived a CompletedStoryCount field, I can display that field as a bar chart by
         * specifying:
         *   return [{
         *      "field": "CompletedStoryCount",
         *      "as": "Completed Stories",
         *      "f": "sum",
         *      "display": "column"
         *   }];
         *
         * The field is displayed in the chart as "Completed Stories" with each bar being a sum of that days completed
         * stories.
         *
         * Object properties:
         *
         *   - The `field` property is the field name to use to calculate the metric. This can be a field from the data
         *   or a derived field.
         *   - The `as` property is the name displayed to the user in the chart
         *   - The `f` property can be a built in Lumenize function string or a custom function that takes `snapshot` as
         *   an argument
         *   - The `display` property is used by the chart to determine how to display the data on a chart. Can be any
         *   Highcharts specific type, e.g., "line" or "column"
         *
         * @return {Array} a list of metric objects
         */
        getMetrics: function () {
            return [];
        },

        /**
         * Calculate summary metrics based on the data retrieved from the store. This is passed to the Lumenize
         * {@link Rally.data.lookback.Lumenize.TimeSeriesCalculator TimeSeriesCalculator} as part of the configuration.
         * Each summary metric also has access to any previously defined metrics or derived fields. This function is
         * useful to generate data that you do not necessarily want to render on the chart, but would like to use to get
         * more derived fields after the main chart metrics are defined. For example, if you wanted the max numbers for
         * different fields, you would specify:
         *      return [
         *          { "field": "TaskUnitScope", "f": "max" },
         *          { "field": "TaskUnitBurnDown", "f": "max" },
         *      ];
         *
         * The fields would then be available to the objects in #getDerivedFieldsAfterSummary. Note that the fields in
         * this case will need to be referenced by `TaskUnitScope_max` due to the use of the built-in `max` function. If
         * you wish to specify your own function, you must use the `as` property in order to reference the field in the
         * future. For example,
         *      return [{
         *          "as": "TaskUnitBurnDown_max_index",
         *          "f": function(seriesData, metrics) {
         *              var i, length = seriesData.length;
         *              for(i = 0; i < length; i++) {
         *                  var data = seriesData[i];
         *                  if(data.TaskUnitBurnDown == metrics.TaskUnitBurnDown_max) {
         *                      return i;
         *                  }
         *              }
         *          }
         *      }];
         *
         * Object properties:
         *
         *   - The `field` property is the name of the field to use to calculate the new summary metric. This field
         *   can be from the data or from a previously derived field.
         *   - The `as` property is only used when you supply a custom function to calculate the summary metric. It is
         *   the name for future reference of the field.
         *   - The `f` property can be a built in Lumenize function string or a custom function that takes `seriesData`
         *   and `metrics` as arguments. This is used in conjunction with the `as` property.
         *
         * @return {Array}
         */
        getSummaryMetricsConfig: function () {
            return [];
        },

        /**
         * Calculate extra chart fields to display on the chart using the fields defined in by the summary metrics
         * configuration. This is passed to the {@link Rally.data.lookback.Lumenize.TimeSeriesCalculator} as
         * part of the configuration. This function is useful when you want to derive more fields to display on your
         * chart. For example, if you wanted to calculate an ideal line for a burn chart using the `TaskUnitScope_max`
         * field, you would specify:
         *      return [{
         *          "as": "Ideal",
         *          "f": function(snapshot, index, metrics, seriesData) {
         *              var max = metrics.TaskUnitScope_max,
         *                  increments = seriesData.length - 1,
         *                  incrementAmount = max / increments;
         *
         *              return Math.floor(100 * (max - index * incrementAmount)) / 100;
         *          },
         *          "display": "line"
         *      }];
         *
         * This field would be displayed in the chart as an ideal line for the given data.
         *
         * Object properties:
         *
         *   - The `as` property is the name displayed to the user in the chart
         *   - The `f` property is a custom function that takes a snapshot, index, chart metrics, and the series data as
         *   arguments
         *   - The `display` property is used by the chart to determine how to display the data on a chart. Can be any
         *   Highcharts specific type, e.g., "line" or "column"
         *
         * @return {Array}
         */
        getDerivedFieldsAfterSummary: function () {
            return [];
        },

        /**
         * @inheritdoc
         */
        runCalculation: function (snapshots) {
            console.log("runCalculations",snapshots.length, snapshots);
            
            var snaps_by_oid = this._aggregateSnapshots(snapshots);
            
            var granularity = "month";
            var dateFormat = "F";
            var date_buckets = this._getDateBuckets(this.startDate, this.endDate, granularity);
            var series = this._getSeries(snaps_by_oid,date_buckets,granularity);
            var categories = this._formatCategories(date_buckets, dateFormat);  
            console.log({categories: categories, series: series});
            return {categories: categories, series: series};
        },
        _getDateBuckets: function(startDate, endDate, granularity){
            console.log('_getDateBuckets',startDate,endDate,granularity);
            var start_year = startDate.getFullYear();
            var start_month = startDate.getMonth();
            var start_day = startDate.getDate();  
            if (granularity == "month"){
                start_day = 1; 
            }
            
            var end_year = endDate.getFullYear();
            var end_month = endDate.getMonth();
            var end_day = endDate.getDate() + 1; 
            if (granularity == "month"){
                //months are zero-based and 0 day returns the last day of the previous month
                end_day = new Date(end_year, end_month+1,0).getDate();
            }
            console.log(end_year,end_month,end_day);
            var bucketStartDate = new Date(start_year,start_month,start_day,0,0,0,0);
            var bucketEndDate = new Date(end_year,end_month,end_day,0,0,0,0);
            var date = bucketStartDate;
            
            var buckets = []; 
            console.log(bucketEndDate, bucketStartDate);
            while (date<bucketEndDate && bucketStartDate < bucketEndDate){
                buckets.push(date);
                date = Rally.util.DateTime.add(date,granularity,1);
            }
            return buckets;  
            
        },
        _getSeries: function(snaps_by_oid, buckets, granularity){
            
            var total_counter = _.range(buckets.length).map(function () { return 0 }),
                blocked_counter =_.range(buckets.length).map(function () { return 0 });

            Ext.Object.each(snaps_by_oid, function(oid, snaps){
                var oid_end_date = null, oid_start_date = null,
                    oid_blocked_end_date = null, oid_blocked_start_date = null,
                    oid_blocked = false; 
                
                Ext.each(snaps, function(snap){
                    
                    var snap_from_date = Rally.util.DateTime.fromIsoString(snap._ValidFrom);
                    if (oid_start_date == null ||  snap_from_date < oid_start_date){
                        oid_start_date = snap_from_date;
                    }
                    var snap_to_date = Rally.util.DateTime.fromIsoString(snap._ValidTo);
                    if (oid_end_date == null || oid_end_date < snap_to_date){
                        oid_end_date = snap_to_date;
                    }
                    
                    if (snap.BlockedReason && snap.Blocked){
                        oid_blocked = true; 
                        if (oid_blocked_start_date == null || oid_blocked_start_date > snap_from_date){
                            oid_blocked_start_date = snap_from_date;
                        }
                        if (oid_blocked_end_date == null || oid_blocked_end_date < snap_to_date){
                            oid_blocked_end_date = snap_to_date;  
                        }
                    }
                    
                });

                for (var i=0; i<buckets.length; i++){
                    if (oid_end_date >= buckets[i] && oid_start_date < Rally.util.DateTime.add(buckets[i],granularity,1)){
                        total_counter[i]++;
                    }
                    if (oid_blocked){
                        if (oid_blocked_start_date >= buckets[i] && oid_blocked_start_date < Rally.util.DateTime.add(buckets[i],granularity,1)){
                            blocked_counter[i]++;
                        }
                    }
                }
            });
            
            var blocked_pct = _.range(buckets.length).map(function () { return 0 }),
            not_blocked_pct = _.range(buckets.length).map(function () { return 0 });  
            
            for(var i=0; i< buckets.length; i++){
                blocked_pct[i] = blocked_counter[i]/total_counter[i] * 100;
                not_blocked_pct[i] = (total_counter[i] - blocked_counter[i])/total_counter[i] *100;  
            }
            
            return [{name: '% Not Blocked', data: not_blocked_pct, stack: 1},
                    {name: '% Blocked', data: blocked_pct, stack: 1}];
        },

        _formatCategories: function(buckets, dateFormat){
            var categories = [];
            Ext.each(buckets, function(bucket){
                categories.push(Rally.util.DateTime.format(bucket,dateFormat));
            });
            return categories; 
        },
        _aggregateSnapshots: function(snapshots){
            //Return a hash of objects (key=ObjectID) with all snapshots for the object
            var snaps_by_oid = {};
            Ext.each(snapshots, function(snap){
                var oid = snap.ObjectID;
                if (snaps_by_oid[oid] == undefined){
                    snaps_by_oid[oid] = [];
                }
                snaps_by_oid[oid].push(snap);
                
            });
            return snaps_by_oid;
        }
    });
Ext.define('Rally.technicalservices.Toolbox',{
    singleton: true,
    getBeginningOfMonthAsDate: function(dateInMonth){
        var year = dateInMonth.getFullYear();
        var month = dateInMonth.getMonth();
        return new Date(year,month,1,0,0,0,0);
    },
    getEndOfMonthAsDate: function(dateInMonth){
        var year = dateInMonth.getFullYear();
        var month = dateInMonth.getMonth();
        var day = new Date(year, month+1,0).getDate();
        return new Date(year,month,day,0,0,0,0);
    }

});
    Ext.define('Rally.technicalservices.calculator.BlockedArrivalKill', {
        extend: 'Rally.data.lookback.calculator.BaseCalculator',
        logger: new Rally.technicalservices.Logger(),

        config: {
            startDate: null,
            endDate: new Date(),
            granularity: "month",
            categoryDateFormat: null, 
        },

        /**
         * Calculate extra chart fields that are derived based on the data retrieved by the store. This is passed
         * to the Lumenize {@link Rally.data.lookback.Lumenize.TimeSeriesCalculator TimeSeriesCalculator} as part of the
         * configuration. For example, if you want to calculate the number of completed stories, you would simply return
         * if the story is in a completed schedule state or not:
         *   return [{
         *       "as": "CompletedStoryCount",
         *       "f": function(snapshot) {
         *           var ss = snapshot.ScheduleState;
         *           if (ss === "Accepted" || ss === "Released") {
         *               return 1;
         *           }
         *           else {
         *               return 0;
         *           }
         *       }
         *   }];
         *
         * You can use these derived fields as part of the calculator metrics calculation.
         *
         * Object properties:
         *
         *   - The `as` property is the name the field is saved as for future reference
         *   - The `f` property can be a built in Lumenize function string or a custom function that takes `snapshot` as
         *   an argument
         *
         * @return {Array} a list of derived fields objects
         */
        getDerivedFieldsOnInput: function () {
            return [];
        },

        /**
         * Calculate the metrics that are displayed on the chart from the data retrieved by the store. This is passed
         * to the Lumenize {@link Rally.data.lookback.Lumenize.TimeSeriesCalculator TimeSeriesCalculator} as part of the
         * configuration. Metrics calculations can use fields that are derived using the #getDerivedFieldsOnInput
         * function. For example, if I derived a CompletedStoryCount field, I can display that field as a bar chart by
         * specifying:
         *   return [{
         *      "field": "CompletedStoryCount",
         *      "as": "Completed Stories",
         *      "f": "sum",
         *      "display": "column"
         *   }];
         *
         * The field is displayed in the chart as "Completed Stories" with each bar being a sum of that days completed
         * stories.
         *
         * Object properties:
         *
         *   - The `field` property is the field name to use to calculate the metric. This can be a field from the data
         *   or a derived field.
         *   - The `as` property is the name displayed to the user in the chart
         *   - The `f` property can be a built in Lumenize function string or a custom function that takes `snapshot` as
         *   an argument
         *   - The `display` property is used by the chart to determine how to display the data on a chart. Can be any
         *   Highcharts specific type, e.g., "line" or "column"
         *
         * @return {Array} a list of metric objects
         */
        getMetrics: function () {
            return [];
        },

        /**
         * Calculate summary metrics based on the data retrieved from the store. This is passed to the Lumenize
         * {@link Rally.data.lookback.Lumenize.TimeSeriesCalculator TimeSeriesCalculator} as part of the configuration.
         * Each summary metric also has access to any previously defined metrics or derived fields. This function is
         * useful to generate data that you do not necessarily want to render on the chart, but would like to use to get
         * more derived fields after the main chart metrics are defined. For example, if you wanted the max numbers for
         * different fields, you would specify:
         *      return [
         *          { "field": "TaskUnitScope", "f": "max" },
         *          { "field": "TaskUnitBurnDown", "f": "max" },
         *      ];
         *
         * The fields would then be available to the objects in #getDerivedFieldsAfterSummary. Note that the fields in
         * this case will need to be referenced by `TaskUnitScope_max` due to the use of the built-in `max` function. If
         * you wish to specify your own function, you must use the `as` property in order to reference the field in the
         * future. For example,
         *      return [{
         *          "as": "TaskUnitBurnDown_max_index",
         *          "f": function(seriesData, metrics) {
         *              var i, length = seriesData.length;
         *              for(i = 0; i < length; i++) {
         *                  var data = seriesData[i];
         *                  if(data.TaskUnitBurnDown == metrics.TaskUnitBurnDown_max) {
         *                      return i;
         *                  }
         *              }
         *          }
         *      }];
         *
         * Object properties:
         *
         *   - The `field` property is the name of the field to use to calculate the new summary metric. This field
         *   can be from the data or from a previously derived field.
         *   - The `as` property is only used when you supply a custom function to calculate the summary metric. It is
         *   the name for future reference of the field.
         *   - The `f` property can be a built in Lumenize function string or a custom function that takes `seriesData`
         *   and `metrics` as arguments. This is used in conjunction with the `as` property.
         *
         * @return {Array}
         */
        getSummaryMetricsConfig: function () {
            return [];
        },

        /**
         * Calculate extra chart fields to display on the chart using the fields defined in by the summary metrics
         * configuration. This is passed to the {@link Rally.data.lookback.Lumenize.TimeSeriesCalculator} as
         * part of the configuration. This function is useful when you want to derive more fields to display on your
         * chart. For example, if you wanted to calculate an ideal line for a burn chart using the `TaskUnitScope_max`
         * field, you would specify:
         *      return [{
         *          "as": "Ideal",
         *          "f": function(snapshot, index, metrics, seriesData) {
         *              var max = metrics.TaskUnitScope_max,
         *                  increments = seriesData.length - 1,
         *                  incrementAmount = max / increments;
         *
         *              return Math.floor(100 * (max - index * incrementAmount)) / 100;
         *          },
         *          "display": "line"
         *      }];
         *
         * This field would be displayed in the chart as an ideal line for the given data.
         *
         * Object properties:
         *
         *   - The `as` property is the name displayed to the user in the chart
         *   - The `f` property is a custom function that takes a snapshot, index, chart metrics, and the series data as
         *   arguments
         *   - The `display` property is used by the chart to determine how to display the data on a chart. Can be any
         *   Highcharts specific type, e.g., "line" or "column"
         *
         * @return {Array}
         */
        getDerivedFieldsAfterSummary: function () {
            return [];
        },
        runCalculation: function (snapshots) {
            this.logger.log("runCalculations snapshots",snapshots.length, snapshots);
            
            var snaps_by_oid = this._aggregateSnapshots(snapshots);
            var buckets = this._getDateBuckets(this.startDate, this.endDate, this.granularity); 
            
            //Blocked during month, unblocked during month 
            var series = this._getSeries(snaps_by_oid, buckets);

            var categories = this._formatCategories(buckets, this.dateFormat);  
            console.log(series, categories);
            return {categories: categories, series: series};
        },
        _getSeries: function(snaps_by_oid, date_buckets){

            var blocked_buckets = [];
            var unblocked_buckets = [];
            for (var i=0; i<date_buckets.length; i++){
                blocked_buckets[i] = 0;
                unblocked_buckets[i] = 0;
            }
            var data = [];
            Ext.Object.each(snaps_by_oid, function(oid, snaps){
                var last_blocked_time = null; 
                var data_record = {ObjectId: oid, FormattedId: null, BlockedDate: null, UnblockedDate: null};
                Ext.each(snaps, function(snap){
                    var formatted_id = snap.FormattedID;  
                    data_record['FormattedId']=formatted_id;
                    var is_blocked = snap.Blocked;
                    var was_blocked = is_blocked;  
                    if (snap._PreviousValues && (snap._PreviousValues.Blocked != undefined)){
                        was_blocked = snap._PreviousValues.Blocked;
                    }
                    
                    var has_reason = false; 
                    if (snap.BlockedReason && snap.BlockedReason.length >0){
                        has_reason = true; 
                    }
                    var had_reason = has_reason;  
                    if (snap._PreviousValues && (snap._PreviousValues.BlockedReason != undefined)){
                        had_reason = false;  
                        if (snap._PreviousValues.BlockedReason && snap._PreviousValues.BlockedReason.length > 0){
                            had_reason = true; 
                        };
                    }
                    var date = Rally.util.DateTime.fromIsoString(snap._ValidFrom);
                    if (was_blocked && had_reason && (is_blocked == false)){
                        for(var i=0; i< date_buckets.length; i++){
                            if (date >= date_buckets[i] && date < Rally.util.DateTime.add(date_buckets[i],this.granularity,1)){
                                unblocked_buckets[i]++; 
                            }
                        }
                        data_record['UnblockedDate'] = date; 
                        last_blocked_time = null;  
                    } 
                    
                    if (is_blocked && (was_blocked == false)){
                        last_blocked_time = date; 
                    }

                    if (is_blocked && has_reason && last_blocked_time){
                        for(var i=0; i< date_buckets.length; i++){
                            if (last_blocked_time >= date_buckets[i] && last_blocked_time < Rally.util.DateTime.add(date_buckets[i],this.granularity,1)){
                                blocked_buckets[i]++; 
                            }
                        }
                        data_record['BlockedDate']=last_blocked_time;
                        last_blocked_time = null;  
                    }
                },this);
                if (data_record.UnblockedDate != null || data_record.BlockedDate != null){
                    data.push(data_record);
                }
            },this);
            this.data = data;
            return [{name:'Blocked', data: blocked_buckets},{name:'Unblocked', data: unblocked_buckets}];  
        },
        _getDateBuckets: function(startDate, endDate, granularity){

            var bucketStartDate = Rally.technicalservices.Toolbox.getBeginningOfMonthAsDate(startDate);
            var bucketEndDate = Rally.technicalservices.Toolbox.getEndOfMonthAsDate(endDate);
           
            this.logger.log('_getDateBuckets',startDate,bucketStartDate,endDate,bucketEndDate,granularity);
            
            var date = bucketStartDate;
            
            var buckets = []; 
            while (date<bucketEndDate && bucketStartDate < bucketEndDate){
                buckets.push(date);
                date = Rally.util.DateTime.add(date,granularity,1);
            }
            return buckets;  
        },
        _formatCategories: function(buckets, dateFormat){
            var categories = [];
            Ext.each(buckets, function(bucket){
                categories.push(Rally.util.DateTime.format(bucket,dateFormat));
            });
            return categories; 
        },
        
        /**
         * aggregateSnapsots:  returns a hash of objects (key = ObjID) with all snapshots for the object
         */
        _aggregateSnapshots: function(snapshots){
            //Return a hash of objects (key=ObjectID) with all snapshots for the object
            var snaps_by_oid = {};
            Ext.each(snapshots, function(snap){
                var oid = snap.ObjectID;
                if (snaps_by_oid[oid] == undefined){
                    snaps_by_oid[oid] = [];
                }
                snaps_by_oid[oid].push(snap);
                
            });
            return snaps_by_oid;
        },
        getData: function(){
            return this.data;  
        }
    });
Ext.define('CustomApp', {
    extend: 'Rally.app.App',
    componentCls: 'app',
    logger: new Rally.technicalservices.Logger(),
    items: [
        {xtype:'container',itemId:'selection_box', layout: {type: 'hbox'}, padding: 10},
        {xtype:'container',itemId:'display_box'},
        {xtype:'tsinfolink'}
    ],
    
    chartTitle: 'Historical Blocker Status',
    pickerOptions: [
                    {name: 'Last Complete Month', value: -1},
                    {name: 'Last 2 Complete Months', value: -2},
                    {name: 'Last 3 Complete Months', value: -3},
                    {name: 'Last 6 Complete Months', value: -6},
                    {name: 'Last 12 Complete Months', value: -12}
                ],
    defaultPickerOption: 'Last 3 Complete Months',
    launch: function() {
        this._initialize();
        
    },
    _initialize: function(){
                    var store = Ext.create('Ext.data.Store',{
                        fields: ['name','value'],
                        data: this.pickerOptions
                    });
                    
                    var cb = this.down('#selection_box').add({
                        xtype: 'combobox',
                        store: store,
                        queryMode: 'local',
                        fieldLabel: 'Show data from',
                        labelAlign: 'right',
                        displayField: 'name',
                        valueField: 'value',
                        value: -3,
                        listeners: {
                            scope: this,
                            select: this._buildChartNew  
                        }
                    });
                    
                    this.down('#selection_box').add({
                        xtype: 'rallybutton',
                        text: 'Data...',
                        itemId: 'btn-data',
                        margin: '0 0 0 10',
                        scope: this, 
                        handler: this._viewData,
                        //disabled: true
                    });

                    this._buildChartNew(cb);
    },    
    _viewData: function(){
        this.logger.log('_viewData');
        
        var data = this.down('#crt').calculator.getData();  
        Ext.create('Rally.technicalservices.DataExportDialog', {
            draggable: true,
            modal: true,
            autoShow: true,
            title: 'Data Dialog 2',
            data: data
        });
    },
    _maskWindow: function(mask){
        this.down('#btn-data').setDisabled(mask);
        this.setLoading(mask);
    },
    _fetchData: function(cb){

        this._maskWindow(true);
        var start_date = Rally.util.DateTime.add(new Date(),"month",cb.getValue());
        var project = this.getContext().getProject().ObjectID;  
        
        this.logger.log('_fetchData', start_date, project);
        Ext.create('Rally.technicalservices.BlockedArtifact.Store',{
            startDate: start_date,
            project: project,
            listeners: {
                scope: this,
                artifactsloaded: function(blockedArtifacts,success){
                    this.logger.log('artifactsLoaded', blockedArtifacts, success);
                    this._buildChart(blockedArtifacts,start_date);
                    this._maskWindow(false);
                }
            }
        });
    },
    _buildChartNew: function(cb){
        
        var start_date = Rally.technicalservices.Toolbox.getBeginningOfMonthAsDate(Rally.util.DateTime.add(new Date(), "month",cb.getValue()));
        var project = this.getContext().getProject().ObjectID; 

        var types = ['HierarchicalRequirement','Defect','Task'];
        var dateFormat = "F";
        var dateInterval = "month";

        this.logger.log('_buildChart', start_date, project);

        this.down('#display_box').removeAll(); 
        
        this.down('#display_box').add({
            xtype: 'rallychart',
            itemId: 'crt',
            loadMask: false,
            storeConfig: {
                hydrate: ['_TypeHierarchy'],
                fetch: ['Blocked','_PreviousValues.Blocked','BlockedReason','_PreviousValues.BlockedReason','_TypeHierarchy'],
                compress: true, 
                find: {
                $or: [
                      {"BlockedReason": {$exists: true}},
                      {"_PreviousValues.BlockedReason": {$exists: true}},
                      {"Blocked": true},
                      {"_PreviousValues.Blocked": true}
                ],
                "_ValidFrom": {$gt: start_date},
                "_TypeHierarchy": {$in: types},
                "_ProjectHierarchy": {$in: [project]}
                },
                sort: {"_ValidFrom": 1} //sort ascending
            },
            calculatorType: 'Rally.technicalservices.calculator.BlockedArrivalKill',
            calculatorConfig: {
                granularity: "month",
                dateFormat: "F",
                startDate: start_date
            },
            chartConfig: {
                    chart: {
                        type: 'column'
                    },
                    title: {
                        text: this.chartTitle
                    },
                    yAxis: {
                        min: 0,
                        title: {
                            text: 'Blockers'
                        }
                    }
             }
        });
    },   
    _buildChart: function(artifacts,startDate){
        this.logger.log('_buildChart artifacts', artifacts);

        this.down('#display_box').removeAll(); 
        
        var dateFormat = "F";
        var dateInterval = "month";
        
//        var categories = Rally.technicalservices.BlockedToolbox.getDateBucketsForArtifacts(artifacts, ["blockedDate","unblockedDate"], dateInterval, dateFormat);
        
        var categories = Rally.technicalservices.BlockedToolbox.getDateBuckets(startDate, new Date(), dateInterval);
        categories = Rally.technicalservices.BlockedToolbox.formatCategories(categories, dateFormat);
        var new_blockers = Rally.technicalservices.BlockedToolbox.bucketDataByDate(artifacts,"blockedDate",dateInterval,dateFormat,categories);
        var resolved_blockers = Rally.technicalservices.BlockedToolbox.bucketDataByDate(artifacts,"unblockedDate",dateInterval,dateFormat,categories);
        
        this.logger.log('_buildChart blocker data (new, resolved)', new_blockers, resolved_blockers);
 
        var series = [];
        var nb_data = [], rb_data = []; 
        Ext.each(categories, function(category){
            nb_data.push(new_blockers[category]);
            rb_data.push(resolved_blockers[category]);
        },this);
        series.push({name: "New Blockers", data: nb_data});
        series.push({name: "Resolved Blockers", data: rb_data});
        
        this.logger.log('_buildChart', 'categories',categories,'series', series);
        
        this.down('#display_box').add({
            xtype: 'rallychart',
            loadMask: false,
            chartData: {
                series: series,
                categories: categories
            }, 
            chartConfig: {
                    chart: {
                        type: 'column'
                    },
                    title: {
                        text: this.chartTitle
                    },
                    yAxis: {
                        min: 0,
                        title: {
                            text: 'Blockers'
                        }
                    }
            }
        });
    }
});
            
               Rally.launchApp('CustomApp', {
                   name: 'Blocker Arrival Kill'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}
    </style>

</head>
<body></body>
</html>